kpatch on s390x
===============

kpatch on s390x is a work in progress. Here are some notes to document the
known quirks, required changes, and progress made so far.

ftrace function prologue
------------------------

s390x doesn't support the -mfentry option in gcc, but it does have -mhotpatch.
This option generates a "hot-patching" function prologue for all functions.
TODO: thus create-diff-object must be modified to take this into account, when
checking whether a function is patchable/hookable by ftrace. arch/s390x/kernel/ftrace.c
has a nice big comment explaining what the function prologues look like when
using mcount or when using using gcc's -mhotpatch feature (excerpt reproduced below).
```
/*
 * In case we use gcc's hotpatch feature the original and also the disabled
 * function prologue contains only a single six byte instruction and looks
 * like this:
 * >    brcl    0,0                     # offset 0
 * To enable ftrace the code gets patched like above and afterwards looks
 * like this:
 * >    brasl   %r0,ftrace_caller       # offset 0
 */
```
Using objdump we can see those 6 bytes (brcl, 0xc004) as the first instruction in all
hookable functions in the kernel:
```
   0:   c0 04 00 00 00 00       brcl    0,0 <find_module_all>
```

Elf oddities
------------
- To my knowledge, s390 doesn't have `.parainstructions`, `.altinstructions`, or
  `.altinstr_replacement` sections (the s390 kernel code has no mention of
  these sections).

- String information is pointed at by `.LC*` symbols, suffixed by a number.
  Each `.LC*` symbol "points" to a string often in the `.rodata.str*`
  section(s). Similarly, the `.LASF*` symbols point to the `.debug_str`
  section(s). The symbol values are the offsets into the `.rodata*` sections,
  which point to a string.  Don't be surprised by the number of `.LC*` and
  `.LASF*` symbols in the symbol table. A lot of relocations will also point
  to these symbols.

  KNOWN ISSUE: Sometimes the `.LC*` symbols receive different number suffixes
  on a kernel rebuild. For example, if symbol `.LC100` pointed to string
  "hello" in the `.rodata.str` section, on a kernel rebuild this symbol name
  may change to have a different number suffix, say `.LC200`. Although the
  symbol name has changed, the string they point to stays the same. This
  trips up create-diff-object symbol correlation from time to time. For
  the *small* patches I've tried out so far, these symbols retain the same name
  for the most part.

- .eh_frame is included in s390x but discarded in vmlinux.lds.S in x86, so
  I currently have create-diff-object automatically include it as a debug
  section with the rest of the .debug* sections for now.

Kernel memory layout on s390x
-----------------------------

The module area (`MODULES_VADDR`) is placed at the end of the kernel
address space on s390x (see: arch/s390/kernel/setup.c). On a 64-bit address
space, this creates issues for kpatch when attempting to stick patched code
for vmlinux in a patch kernel module. Namely, the main obstacle we've run
into is when the compiled code uses R_390_PC32DBL relocations, which
utilize 32-bit relative displacements. However, kernel modules are placed
at the tail end of the kernel address space, rendering these relocations
non-functional, since the displacement to vmlinux symbols on the other end
of the address space is larger than what can fit in a 32-bit field.

Andreas Krebbel (s390 gcc maintainer) and Martin Schwidefsky (s390 kernel
maintainer) have suggested the usage of -mno-pic-data-is-text-relatve to
transform these relocations (and compiled code) to use position independent
relocations, i.e. go through the PLT for function calls and the GOT for
data accesses. Note: Martin was not supportive of moving the start of
MODULES_VADDR closer to the kernel image, as this would nontrivally change
the way they plan to implement kaslr on s390.

The new planned gcc option forces *all* function calls and data references,
both local and global, to go through these two tables. This requires
building the patch module with both `-fPIC` and
`-mno-pic-data-is-text-relative`, which transforms all the R_390_PC32DBL
relocations to R_390_PLT32DBL or R_390_GOTENT. This means that we no longer
have the 32-bit displacement issue and the s390 kernel module loader will
create the necessary PLT/GOT entries for us.

Status as of June 2017
----------------------

Andreas Krebbel has gotten the new `-mpic-data-is-text-relative` into gcc
mainline. We're now going to need to answer the following question: How are
we going to build the resulting patch module with this new gcc option set?
kpatch-build does two build passes: one build for the original kernel and
another build for the patched kernel. During these passes we do not enable
-mpic-data-is-text-relative because that would create a lot of deviations
from the original running kernel. One suggestion from kpatch summit:
perhaps we can do the two builds without the option, build the patch module
without the option, rebuild the objects of interest _with_ the option,
create final patch module based on the included sections and symbols in the
first patch module.
